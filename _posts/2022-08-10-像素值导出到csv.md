---
layout:     post
title:      Google Earth Engine(GEE) 像素值导出到CSV：sampleRegions()函数的使用
subtitle:   GEE踩坑记录
date:       2022-08-09
author:     liyang
header-img: img\GoodnightCopenhagen.png
catalog: true
tags:
    - GEE
---
## Google Earth Engine(GEE) 像素值导出到CSV

### 1. 单个像素点的导出
对于研究区为点数据时，有时我们只想知道影像在这一点的像素值，比如计算某点的NDVI变化，或者查看多个点的NDVI空间异质性。如果导出图像比较麻烦（毕竟我们只要一个点的数据），因此可以直接将像素值导出到文本文件（csv）中，省得提交多个任务，然后下载csv处理。
这里关键使用的函数就是sampleRegions()：
贴一下官方的用法说明：

**sampleRegions()：**
Converts each pixel of an image (at a given scale) that intersects one or more regions to a Feature, returning them as a FeatureCollection. Each output feature will have one property per band of the input image, as well as any specified properties copied from the input feature.

Note that geometries will be snapped to pixel centers.

**Arguments**:
**this:**image (Image):
The image to sample.

**collection (FeatureCollection):**
The regions to sample over.

**properties (List, default: null):**
The list of properties to copy from each input feature. Defaults to all non-system properties.

**scale (Float, default: null):**
A nominal scale in meters of the projection to sample in. If unspecified,the scale of the image's first band is used.

**projection (Projection, default: null):**
The projection in which to sample. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale.

**tileScale (Float, default: 1):**
A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default.

**geometries (Boolean, default: false):**
If true, the results will include a point geometry per sampled pixel. Otherwise, geometries will be omitted (saving memory).

**Returns**: FeatureCollection

一个用法示例：
```javascript
var img_value = img.sampleRegions({
    collection:feature_region,
    properties:ee.List(['name']),
    scale:30
    })
```


### 2. 多个像素点导出的麻烦：

以上代码，可以从给定的 feature_region 中，计算每个像素的值，导出到一个FeatureCollection 中，之后再使用Export.table.toDrive()函数，得到包含每个像素值的csv文件。如果是多个点，那么只要使用迭代，将每次得到的FeatureCollection merge 一下，就可以得到多个点的csv文件：
```JavaScript
function fill(feature,ini){
    var feature_region = XX // point region
    var img = XX // your image 
    var inift = ee.FeatureCollection(ini) // inital file
    var img_value = img.sampleRegions({ 
    collection:feature_region,
    properties:ee.List(['name']),
    scale:30
    });
    return inift.merge(ft3) 
  };

// 不推荐使用for 循环，推荐使用iterate 遍历，第一个参数为function，第二个参数为the initial state.
  var ft2011 = ee.FeatureCollection(ee.List([]))
  var datalist2011 = table2011.toList(1234);
  var fts_data2011 = ee.FeatureCollection(datalist2011);
  var newft2011 = fts_data2011.iterate(fill2011,ft2011);
  
  Export.table.toDrive({
    collection: newft2011,
    description: 'BioDiversity_2011_AnnualData',
    fileFormat: 'CSV'
  });
  ```


上面的代码，如果点数量较少，一切都好说，但是如果有上千个点，那就遇到一个问题：
merge()函数的问题，因为我们没循环一个点，就把新计算得到的featureCollection 与之前的FeatureCollection merge 一下。系统在每次merge的时候会自动在系统index前面加个_1。这就意味着如果多次merge，那么每行数据的index名字会特别长，之后就会报错了：

> merge() is too deeply nested.

文档中是这样描述的：
> Merges two collections into one. The result has all the elements that were in either collection. Elements from the first collection will have IDs prefixed with "1_" and elements from the second collection will have IDs prefixed with "2_". Note: If many collections need to be merged, consider placing them all in a collection and using FeatureCollection.flatten() instead. Repeated use of FeatureCollection.merge() will result in increasingly long element IDs and reduced performance.

这个时候就得用列表+.flatten() 函数了
具体代码如下：
```JavaScript
function fill(feature,ini){

    var feature_region = XX
    var imgCollection = GetData2011(XX)
    var ft2 = img.sampleRegions({
        collection:feature_region,
        properties:ee.List(['UID']),
        scale:30})
    var newlist = ee.List(ini).add(ee.FeatureCollection(ft2))
    return newlist
}

var ft = ee.List([])
var datalist = table.toList(table.size());//table.size()
var fts_data = ee.FeatureCollection(datalist);
var newft = fts_data.iterate(fill,ft);
var newftnew = ee.List(newft)
var totabel_ite = ee.FeatureCollection(newftnew).flatten();

Export.table.toDrive({
  collection: totabel_ite,
  description: 'BioDiversity_2016_CollectionDate',
  fileFormat: 'CSV'
})

```




## next: GEE 经验贴

### 1. 像素值导出到csv：sampleRegions()

### 3. 异常处理：ee.Algorithms.If（）

### 4. getinfo()函数的使用

